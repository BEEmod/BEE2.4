from typing import Any, Literal, NoReturn, Protocol, Self, overload

from collections.abc import (
    Callable, Iterable, Iterator, MutableMapping, MutableSet,
)


__version__: str
_EMPTY: _NoChildren

class ShortKeyError(KeyError): ...

class _CopyFunc(Protocol):
    def __call__[T](self, value: T, /) -> T: ...

class _NoChildren(Iterator[Any]):
    def __bool__(self) -> Literal[False]: ...
    def __len__(self) -> Literal[0]: ...
    def __iter__(self) -> _NoChildren: ...
    def iteritems(self) -> _NoChildren: ...
    def sorted_items(self) -> _NoChildren: ...
    def __next__(self) -> NoReturn: ...
    def next(self) -> NoReturn: ...
    def get(self, _step: Any) -> None: ...
    def add(self, parent: Any, step: Any) -> _Node: ...
    def require(self, parent: Any, step: Any) -> _Node: ...
    def copy(self, _make_copy: Any, _queue: Any) -> Self: ...
    def __deepcopy__(self, memo: dict[int, Any]) -> Self: ...

class _OneChild[KeyT, ValueT]:
    step: Any = ...
    node: _Node = ...
    def __init__(self, step: Any, node: _Node) -> None: ...
    def __bool__(self) -> bool: ...
    def __len__(self) -> int: ...
    def sorted_items(self) -> list[tuple[KeyT, ValueT]]: ...
    def iteritems(self) -> Iterator[tuple[KeyT, ValueT]]: ...
    def get(self, step: Any) -> _Node | None: ...
    def add(self, parent: Any, step: Any) -> _Node: ...
    def require(self, parent: Any, step: Any) -> _Node: ...
    def delete(self, parent: Any, _step: Any) -> None: ...
    def copy(self, make_copy: Any, queue: Any) -> Self: ...

class _Children(dict[Any, _Node]):
    def __init__(self, *items: Any) -> None: ...
    def sorted_items(self) -> list[tuple[Any, _Node]]: ...
    def iteritems(self) -> Iterator[tuple[Any, _Node]]: ...
    def add(self, _parent: Any, step: Any) -> _Node: ...
    def require(self, _parent: Any, step: Any) -> _Node: ...
    def delete(self, parent: Any, step: Any) -> None: ...
    def copy(self, make_copy: Any, queue: Any) -> Self: ...  # type: ignore

class _Node:
    children: Any = ...
    value: Any = ...
    def __init__(self) -> None: ...
    def iterate(self, path: Any, shallow: bool, iteritems: Any) -> Iterator[tuple[Any, Any]]: ...
    def traverse[T](
        self,
        node_factory: Callable[..., T],
        path_conv: Any,
        path: Any,
        iteritems: Any,
    ) -> Iterator[T]: ...
    def equals(self, other: Any) -> bool: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def shallow_copy(self, make_copy: Any) -> Self: ...
    def copy(self, make_copy: Any) -> Self: ...

type AnyNode[KeyT, ValueT] = _Node | _NoChildren | _OneChild[KeyT, ValueT]

class _TrieStep[StepKeyT, StepValueT]:
    # Actually defined in Trie, but doesn't use generics from there.
    def __init__(
        self,
        trie: Trie[StepKeyT, StepValueT],
        path: StepKeyT,
        pos: int,
        node: AnyNode[StepKeyT, StepValueT],
    ) -> None: ...

    def __bool__(self) -> bool: ...
    def __getitem__(self, index: int) -> StepValueT: ...

    @property
    def is_set(self) -> bool: ...

    @property
    def has_subtrie(self) -> bool: ...

    def get[T](self, default: T | None = None) -> StepValueT | T: ...
    def set(self, value: StepValueT) -> None: ...
    def setdefault(self, value: StepValueT) -> StepValueT: ...

    @property
    def key(self) -> StepKeyT: ...

    @property
    def value(self) -> StepValueT: ...

    @value.setter
    def value(self, value: StepValueT) -> None: ...

class Trie[KeyT, ValueT](MutableMapping[KeyT, ValueT]):
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def enable_sorting(self, enable: bool = ...) -> None: ...
    def clear(self) -> None: ...

    # implements update(), same as superclass.

    def copy(self, make_copy: _CopyFunc = ..., /) -> Self: ...
    def __copy__(self) -> Self: ...
    def __deepcopy__(self, memo: dict[int, Any]) -> Self: ...

    @overload
    @classmethod
    def fromkeys[Key2T](cls, keys: Iterable[Key2T]) -> Trie[Key2T, None]: ...
    @overload
    @classmethod
    def fromkeys[Key2T, Value2T](cls, keys: Iterable[Key2T], value: Value2T) -> Trie[KeyT, Value2T]: ...

    def __iter__(self) -> Iterator[KeyT]: ...
    def iteritems(self, prefix: KeyT = ..., shallow: bool = ...) -> Iterator[tuple[KeyT, ValueT]]: ...
    def iterkeys(self, prefix: KeyT = ..., shallow: bool = ...) -> Iterator[KeyT]: ...
    def itervalues(self, prefix: KeyT = ..., shallow: bool = ...) -> Iterator[ValueT]: ...
    def items(self, prefix: KeyT = ..., shallow: bool = ...) -> list[tuple[KeyT, ValueT]]: ...  # type: ignore  # Py2
    def keys(self, prefix: KeyT = ..., shallow: bool = ...) -> list[KeyT]: ...  # type: ignore  # Py2
    def values(self, prefix: KeyT = ..., shallow: bool = ...) -> list[ValueT]: ...  # type: ignore  # Py2
    def __len__(self) -> int: ...
    def __bool__(self) -> bool: ...
    __hash__: None = None  # type: ignore
    HAS_VALUE: int
    HAS_SUBTRIE: int
    def has_node(self, key: KeyT) -> bool: ...
    def has_key(self, key: KeyT) -> bool: ...
    def has_subtrie(self, key: KeyT) -> bool: ...
    # TODO: slice can't specify it must always be slice(KeyT, None, None)
    @overload
    def __getitem__(self, key_or_slice: slice) -> Iterator[ValueT]: ...
    @overload
    def __getitem__(self, key_or_slice: KeyT) -> ValueT: ...
    def __setitem__(self, key_or_slice: KeyT | slice, value: ValueT) -> None: ...
    def setdefault(self, key: KeyT, default: ValueT | None = None) -> ValueT: ...
    @overload
    def pop(self, key: KeyT) -> ValueT: ...
    @overload
    def pop(self, key: KeyT, /, default: ValueT) -> ValueT: ...
    @overload
    def pop[T](self, key: KeyT, /, default: T) -> ValueT | T: ...
    def popitem(self) -> tuple[KeyT, ValueT]: ...
    def __delitem__(self, key_or_slice: KeyT | slice) -> None: ...

    class _NoneStep(_TrieStep[None, None]): ...

    def walk_towards(self, key: KeyT) -> Iterator[_TrieStep[KeyT, ValueT]]: ...
    def prefixes(self, key: KeyT) -> Iterator[_TrieStep[KeyT, ValueT]]: ...
    def shortest_prefix(self, key: KeyT) -> _TrieStep[KeyT, ValueT]: ...
    def longest_prefix(self, key: KeyT) -> _TrieStep[KeyT, ValueT]: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def traverse[T](self, node_factory: Callable[..., T], prefix: KeyT = ...) -> T: ...

class CharTrie[ValueT](Trie[str, ValueT]): ...

class StringTrie[ValueT](Trie[str, ValueT]):
    def __init__(self, *args: Any, separator: str = '/', **kwargs: Any) -> None: ...

    @overload  # type: ignore  # Incompatible override
    @classmethod
    def fromkeys(cls, keys: Iterable[str], *, separator: str = ...) -> StringTrie[None]: ...
    @overload
    @classmethod
    def fromkeys(
        cls,
        keys: Iterable[str],
        value: ValueT,
        separator: str = ...,
    ) -> StringTrie[ValueT]: ...

class PrefixSet[KeyT](MutableSet[KeyT]):
    # TODO: Used as factory(**kwargs), but can't express that.
    def __init__(
        self,
        iterable: Iterable[KeyT] = ...,
        factory: Callable[..., Trie[KeyT, Any]] = ...,
        **kwargs: Any,
    ) -> None: ...
    def copy(self) -> PrefixSet[KeyT]: ...
    def __copy__(self) -> PrefixSet[KeyT]: ...
    def __deepcopy__(self, memo: dict[int, Any]) -> PrefixSet[KeyT]: ...
    def clear(self) -> None: ...
    def __contains__(self, key: object) -> bool: ...
    def __iter__(self) -> Iterator[KeyT]: ...
    def iter(self, prefix: KeyT = ...) -> Iterator[KeyT]: ...
    def __len__(self) -> int: ...
    def add(self, value: KeyT) -> None: ...
    # Not implemented.
    def discard(self, value: KeyT) -> NoReturn: ...
    def remove(self, value: KeyT) -> NoReturn: ...
    def pop(self) -> NoReturn: ...
